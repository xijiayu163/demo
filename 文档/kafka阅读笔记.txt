kafka 文档阅读理解

通过配置可以设置集群中的消息的存储。比如设置保留2天，那么在2天内可以被任意组去消费，2天之后就会被删除以释放空间

kafka的性能支持它可以长期存储数据

消费者组的提交偏移量是保存在broker的日志中

消费者控制提交偏移量，一般是线性消费，但实际上它可以以任意顺序来消费。
比如可以重新读取记录或者跳过某些记录从now开始。这种设计意味者消费者
是非常廉价的，它可以来也可以去，不会对broker造成什么影响。

分区的意义：
1 允许topic的记录本身超过单个broker的容量，一个topic有多个分区，分区可以分散在多个broker上。
2 可以支持并发，比如多个消费者同时从多个broker消费，提高效率

可以设置备份因子，这样一个partition就会有多个备份在不同的broker上。
每个partition都有一个broker作为leader，其它存放该分区的broker就是follower，follower可以有0~N个。
leader处理所有的数据读写，follower只是复制数据以及leader处理后的状态。这样可以达到高可用
如果leader挂了，某一个follower将自动成为新的leader(就像zookeeper的选举机制一样)
每一个server都扮演一部分partitions的leader同时也扮演另一部分partitions的follower，所以整个集群是负载均衡的

生产者负责将消息发往哪个主题的哪个分区。通过配置可以采取轮询机制或者其它机制(比如按key区分)。

每一个消费者都有一个组名。一个组订购某个topic或某几个topic，那么被订购的topic中的每个记录都会被这个组消费且正常情况下只被消费一次。
组内的消费者共同承担负载均衡的目的。一个组内的消费者可以在不同的处理器中或者在不同的机器上。
如果每个消费者都有唯一的组名，那么订阅的主题中的每个记录都将被这个消费者消费。
如果所有的消费者都有一个共同的组名，那么订阅的主题将会被这个组内所有的消费者共同消费，达到负载均衡。

被订购的主题中的每个分区都被kafka标记使用哪个消费者来消费，所以每个消费者实例在任何时间点都是"公平分享"分区的独占消费者。也就是说
一个分区对于一个组来说在任何时间点只有一个消费者消费(独占消费)。

分区内的记录是排序的，但是不同分区的记录不排序。默认以记录的key来分区基本上满足大部分的应用要求。
如果需要一个topic的所有记录都是排序的，那么就把记录全部放在一个分区中。同时意味者每个组中只有一个消费者在消费这个topic

kafka的保证：
1 消息被发往某个分区时将以发送的时机正确排序。也就是说如果记录M1被生产者发送的时间早于M2，则不管任何情况，当M1和M2到达分区中后肯定是M1排在
M2的前面，即便是因为网络因素导致M2先收到。
2 消费者看到的记录都是排序的，和分区中存储的顺序一样
3 如果一个topic被配置的复制因子为N，那么即使有N-1个服务器挂掉，记录都不会被丢失。

kafka与消息系统的对比
消费者组同时支持消息系统中队列和发布订阅的机制。
对于队列，只使用一个消费者组去订购主题，那么就达到了队列的效果，同时也支持负载均衡。而且还保证消息至少消费一次。
对于发布订阅，可以同时配置多个分组去订购主题，而且对于同组内的消费更有负载均衡的效果(这个是传统消息系统不支持的)。

同时kafka更能保证消息的排序行
传统的消息系统是消息在broker内部排序存储，如果有多个消费者消费，server将这些记录按存储的顺序发出。但是尽管是按顺序发出，记录被传递到多个消费者
那的时候是异步的，因此当到达多个消费者的时候有可能是乱序的。也就是说在并发消费的时候消息的有序性是不能保证的。消息系统解决这个问题的方法
是设置"exclusive consumer"表示只允许一个消费者来消费这个队列，但同时这样做也丢掉了并发处理的效率以及负载均衡特性的丢失。
kafka通过指定一个topic下的某个分区只能被一个组内的某一个消费者消费的机制，也就是说同组内的不同消费分别负责消费不同的分区，
而kafka又保证单个consumer见到的分区记录又是排序的。通过这样可以保证topic下的消息都是顺序消费的，并且也达到了负载均衡。
(但要注意的一点是，同组内的消费者数量不能超过分区的数量！)

kafka作为一个存储系统
写入Kafka的数据写入磁盘并进行复制以实现容错。 Kafka允许生产者等待确认，
以便在完全复制之前写入不被认为是完整的，并且即使写入的服务器失败也能保证持续。
可以将kafka认为是一个特殊的分布式文件系统以支持高性能，低延迟的提交日志存储，复制和传播

kafka的流式处理
主要方式是读取topic，处理topic，然后再发送处理后的topic
流式处理的API都基于生产者和消费者还有存储特性来封装，进而对外提供。



































