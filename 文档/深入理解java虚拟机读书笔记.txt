虚拟机栈(堆栈) 本地方法栈 程序计数器 堆 方法区(Non-heap 非堆)

进程1：1堆  
进程1：1方法区

线程
程序计数器1:1线程 指示线程中的代码执行位置。
虚拟机栈1:1 线程   方法1：1栈帧 =>虚拟机栈(入栈 出栈)
本定方法栈1：1线程。

虚拟机栈：
局部变量表 存放编译器可知的基本数据类型及对象的引用
	内存分配在编译器完成，进入一个方法时这个方法需要在栈帧分配多大的局部变量空间是完全确定的。运行期间不会改变局部变量表的大小
	异常1：线程请求的栈深度大于虚拟机允许的深度，抛出stackoverflowError异常。前提是虚拟机设置固定长度的虚拟机栈
	异常2：虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存，就会抛出outofMemoryError异常。

本地方法栈：与虚拟机栈类似，不过是为本地方法服务的。由具体的虚拟机自由实现。例如hotspot将本地方法栈和虚拟机栈合二为一。

堆
所有线程共享的内存区域
也被成为GC堆，由GC堆维护对象的生命周期
异常：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError

方法区：
用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
运行时常量池

直接内存：并不是虚拟机运行时数据区的一部分。例如 NIO，使用native函数库直接分配堆外内存，然后通过一个存储在
java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在JAVA堆和Native堆中来回复制数据，这也是NIO比BIO高效的原因。

本地线程分配缓冲：解决并发分配内存问题。

堆中分配的对象是有对象头的，对象头包括对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。
对象：对象头，实例数据，对齐填充

对象的访问定位： 1 栈中的reference=>堆中的句柄池，句柄(对象实例数据的指针，对象类型数据的指针)
2 直接指针：reference=>对象地址。


GC
引用计数器，可达性分析，GC Roots

思考：
线程局部变量是存放在线程的虚拟机栈中吗？
局部变量表是对应线程的，那么它的生命周期是怎样的？
垃圾收集机制中引用计数器的缺点是什么？


